# 기말고사와 함께하는 컴퓨터 구조

## 마이크로 컴퓨터

- `마이크로 컴퓨터` : 하나의 칩 속에 `중앙처리장치`가 들어 있는 것으로, 1971년 인텔사가 처음으로 개발하였음
- `마이크로프로세서`에 `LSI(Large Scale Integration)`에 의한 연산처리장치, 기억장치, 입출력장치 등을 부가한 컴퓨터
- 개인용 컴퓨터, 산업용 로봇, 자동차 엔진, 가정용 기기 등에서 **제어장치**로 이용
- `마이크로프로세서` : CPU 혹은 중앙 처리 장치. 컴퓨터에서 기억, 해석, 연산, 제어라는 4대 주요 기능 관할
- `LSI(Large Scale Integration)` : 고밀도 집적회로

## 컴퓨터의 특성

- `신속성` : 입출력 속도와 연산 속도가 빨라서 많은 양의 데이터를 **신속하게 처리**할 수 있음
- `대용량성` : **많은 양의 데이터**를 기억하고 처리할 수 있음
- `신뢰성` : 컴퓨터의 **처리 결과 신뢰** 가능. 주어진 환경 아래에 요구되는 기능을 **원활히 수행**할 수 있음
- `정확성` : **오류 및 오차 최소화**. 정확한 계산 및 정확한 처리 결과
- `범용성` : **많은 분야**에서 다양한 업무 처리 (과학 기술용, 사무 처리용이나 교육 등)

## 그레이 코드 변환 과정

- `그레이 코드` (Gray Code) : 한 번에 한 비트씩 변화 (미지근~하게 변해서 회색 코드라는 뜻)
- 그레이 코드는 아날로그와 디지털 간에 코드를 변환할 때 사용함 
- 아래는 `2진수`를 `그레이 코드`로 변환하는 방법
- 과정1 : 2진수의 `최상위 비트`는 그대로 그레이 코드의 `최상위 비트`
- 과정2 : 2진수의 최상위 비트와 다음 비트를 `더한` 후
- 과정3 : 자리 올림수를 제거한 나머지를 `그레이 코드`로 취함.
- 이하 같은 방법

![image](https://user-images.githubusercontent.com/80818534/145031006-6ca624dd-9add-4291-b0ea-217883f9567f.png)

- 아래는 `그레이 코드`를 `2진수`로 변환하는 방법
- 과정1 : 그레이 코드의 `최상위 비트`는 그대로 2진수의 최상위 비트
- 과정2 : 2진수와 그레이 코드의 다음 비트와 더하여
- 과정3 : 자리 올림수를 제거한 나머지를 `2진수`로 취함.
- 이하 같은 방법

![image](https://user-images.githubusercontent.com/80818534/145032569-bc3da5c7-3a82-4cce-904a-d23ef3279696.png)

## 고급 언어

- `고급언어` : 프로그래밍 언어 (C, PYTHON, JAVA 등)
- `어셈블리어` : 사람이 이해하기 쉬운 단어로 바꾼 것 (MOV, ADD, STA, LDA 등)
- `기계어` : 컴퓨터가 사용하는 언어 (0과 1)

## 소프트웨어 종류

![image](https://user-images.githubusercontent.com/80818534/145032825-24ad4a55-cecd-4473-8ef1-84f64428afa7.png)

- `시스템 소프트웨어` : 하드웨어를 컨트롤할 수 있는 소프트웨어
- `응용 소프트웨어` : 시스템 소프트웨어의 도움을 받아 사용자가 원하는 작업 처리
- `운영체제` : 하드웨어 관리 등 담당. 하드웨어와 사용자 간의 인터페이스 제공
- `유틸리티` : 운영체제 제공 외에 **추가 기능 제공**하여 사용자의 편의를 지원하는 소프트웨어
- `범용 프로그램` : 다수의 사용자가 일반적으로 사용하는 프로그램 ex) MS office, Photoshop, game
- `특수 목적용 소프트웨어` : 기업, 학교, 연구소, 공공 기관 등 특정 분야의 고유 업무 처리를 위한 소프트웨어 ex) 성적 처리, 인사 관리 프로그램

## 하드웨어 구성 요소

- `메인보드` (main board) : 컴퓨터의 부품들을 하나로 연결해주는 회로와, 밖으로 신호를 보내는 출력 포트 가지고 있음
- `CPU` : 중앙처리장치. 컴퓨터에서 기억, 해석, 연산, 제어를 관할하는 장치
- `GPU` : 컴퓨터 시스템에서 **그래픽 연산**을 빠르게 처리하여 결과값 모니터에 출력하는 연산장치
- `주기억장치` : 컴퓨터 메모리. 수치/명령/자료 등 기억하는 장치
- `광 저장장치` : CD-ROM. 광 레이저 기술 이용하여 멀티미디어 정보를 저장/재생
- `HDD, SSD` : 보조기억장치. 비휘발성이며 오프라인 저장 장치.

![image](https://user-images.githubusercontent.com/80818534/145034457-ef6d73a2-94f6-4ca6-89d6-698be2280a7a.png)

## 연산장치 구성요소

- `연산 장치` : 데이터 처리를 위한 **연산**이 이루어지는 곳
- 연산에 사용될 데이터를 받아 제어 장치가 지시하는 순서에 따라 데이터 `산술 연산` 및 `논리 연산` 실행
- 그 결과를 `레지스터(register)` 혹은 `누산기(accumulator)`에 저장
<br><br>
- `데이터 레지스터` : 주기억 장치로부터 **가져온 데이터를 보관**하는 기억 장소
- `가산기` (adder) : 누산기와 레지스터의 **값을 더하여** 그 결과를 누산기에 보관하는 회로
- `누산기` (accumulator) : 연산 장치를 구성하는 중심이 되는 레지스터. 연산의 **중간 결과 기억**
- `오버플로 검출기` : 가산기의 결과가 해당 **레지스터의 용량 초과** 시 검출해 주는 회로
- `상태 레지스터` : 연산 결과의 부호 입력 자리 올림수(carry in), 오버플로, 인터럽트 발생 여부 등 **상태 정보 저장**

![image](https://user-images.githubusercontent.com/80818534/145036025-c250c954-faba-4c6e-9b7a-5c5d8ffb3f18.png)

- 연산 과정
- 1. 제어 장치의 `제어 신호`를 받음
- 2. 주기억 장치에서 데이터를 가져와 `레지스터에 저장`
- 3. 새로운 데이터가 있을 경우에는 주기억 장치에서 가져와 저장
- 4. `누산기`에 있는 값과 `데이터 레지스터`에 있는 값을 이용하여 `연산` 실행
- 5. 상태 정보를 확인, `상태 레지스터`에 상태 정보 저장
- 6. 가산 결과를 `누산기`에 저장
- 7. `주기억 장치`로 결과 저장

## 논리 회로 (논리게이트)

- `논리 연산` : 논리합, 논리곱, 논리부정, 분기, 비교, 시프트, 변환 등
- `논리 연산 회로` : 입력 데이터에 대해 논리 연산을 실행하도록 하는 조합 논리 회로로 만들어진 회로
- 논리 연산에서는 데이터를 비트 또는 바이트 단위로 취급
- `논리곱(AND)` : 주어진 복수 명제 `모두가 참`이어야 결과가 참이 되는 연산
- `논리합(OR)` : 주어진 복수 명제에 `적어도 1개 이상의 참`이 있으면 결과가 참이 되는 연산
- `논리부정(NOT)` : 주어진 명제의 참과 거짓을 `부정`하는 것
<br><br>
- `AND 게이트` : 두 개 이상의 입력이 모두 1일 때 출력이 1인 게이트. (논리곱 회로)
- `OR 게이트` : 두 개 이상의 입력 중 하나 이상 입력이 1일 때 출력이 1인 게이트. (논리합 회로)
- `NOT 게이트` : 입력이 0이면 출력이 1, 입력이 1이면 출력이 0인 게이트. (논리부정 회로)
- `NAND 게이트` : NOT + AND 게이트로써 AND 게이트 출력의 반대가 출력
- `XOR 게이트` : 배타적 논리합(eXclusive OR) 회로로 입력 값이 `서로 다를 때` 출력이 1인 회로

![image](https://user-images.githubusercontent.com/80818534/145044804-382bed23-0680-40b3-9e1c-d15896766818.png)
![image](https://user-images.githubusercontent.com/80818534/145045035-372db7d3-a8c8-418d-ae47-97e861e155c0.png)

## 진수 변환 (2진수, 8진수, 16진수, 10진수)

- 10진수에서 2진수로 변환
![image](https://user-images.githubusercontent.com/80818534/145045930-4825f7a3-b44e-4077-96e4-c701f41c3462.png)

- 10진수에서 8진수로 변환<br>
![image](https://user-images.githubusercontent.com/80818534/145046088-15a69e1d-e764-4731-a47f-d55f6ce9775c.png)

- 10진수에서 16진수로 변환
![image](https://user-images.githubusercontent.com/80818534/145046170-4cc727f0-8149-4e87-94ce-c2a67acbb6a7.png)

- 8진수 <-> 2진수 <-> 16진수
- `8진수`는 2진수에서 `3자리`씩 변환
- `16진수`는 2진수에서 `4자리`씩 변환
- 2진수를 8진수, 16진수로 변환하는 것은 위 과정 역으로 수행

## 제어장치 역할

- 입력 장치에서 입력된 데이터를 `기억 장소에 저장`
- 기억 장치에 있는 데이터를 `연산 장치로 이동`
- 연산 장치에서 연산 완료 시 결과를 `기억 장치로 이동`
- 기억 장치에 저장된 데이터를 `출력 장치로 이동, 출력`
- 입력장치 <-> 기억장치 <-> 연산장치 <-> 기억장치 <-> 출력장치

## 제어장치 구성요소

- `주소 레지스터` (MAR; Memory Address Register) : 주기억 장치에 명령이나 자료가 기억되어 있는 `주소를 보관`
- `기억 레지스터` (MBR; Memory Buffer Register) : 명령어 계수기가 지정하는 주기억 장치의 `내용을 임시 보관`
- `명령어 레지스터` (IR; Instruction Register) : 현재 실행 중인 `명령을 기억`하는 레지스터. 연산 코드와 주소부로 구성
- `명령어 계수기` (PC; Program Counter) : `다음에 실행`할 명령어가 기억되어 있는 주기억 장치의 `주소를 기억`
- `명령어 해독기` (Decoder) : 명령어 레지스터의 `명령 코드를 해독`하여 필요한 실행 신호 발생시킴
- `주소 처리기` (Address Processor) : 피연산자를 인출할 경우 그 `주소를 계산`하거나, 수행될 명령 순서가 바뀔 때 다음에 수행할 명령의 주소 계산
- `순서기` (Sequencer) : 정해진 순서에 따라 `동작 순서를 제어`

![image](https://user-images.githubusercontent.com/80818534/145049089-35fbd92d-09fa-4b42-a912-a499eba20b80.png)

## 제어장치 수행 과정

- 명령어 주소 전송을 위해 `명령어 계수기(PC)`에 기억된 주소를 `MAR`으로 보냄
- `주기억 장치`의 내용을 임시 보관하는 `MBR`에서 읽어온 명령어를 `명령어 레지스터(IR)`에 저장, `명령어 계수기` 1 증가
- 명령어 코드(op Code) 필드와 주소 필드를 각각 `해독기`와 `주소 처리기`로 보냄
- `주소 처리기`는 연산 자료 인출 시 **피연산자의 주소**를 계산. 수행 명령어 바뀔 때는 **다음 명령어 주소를 계산**하여 `명령어 계수기`에 기억시킴
- `제어 신호 발생기`가 **연산자를 해독**하여, 명령어 수행을 위한 제어 신호 발생. 만약 수행 순서 변경 시 `주소 처리기` 동작시켜 명령어 주소 계산
- 다음 명령 수행 위해 위 과정 반복. 현재 `명령어 레지스터`에 있는 명령어의 수행 끝나면 증가된 `명령어 계수기`의 값을 `MAR`에 보내 다음 명령어 실행

![image](https://user-images.githubusercontent.com/80818534/145125824-3316f42e-5e48-4697-b1c3-ce5f8425b848.png)

## 명령어 형식

- `모드(mode)` : 피연산자의 주소가 **직접 주소**인지 **간접 주소**인지 구분
- `명령 코드부(op code)` : 실행할 동작 지시 (연산자)
- `주소부(operand)` : 피연산자가 저장된 주기억 장치의 **주소** 나타냄
- 명령어 형식은 `주소부(operand)`의 주소 수에 따라 구분할 수 있음 (주기억 장치의 위치 나타내는 법 여러 가지)

참고) 직접 주소는 **기억 장소를 주소부에 직접 지정**하는 것이고, 간접 주소는 **데이터가 저장된 주소를 저장하고 있는 기억 장소의 주소를 저장**하는 것이다.

![image](https://user-images.githubusercontent.com/80818534/145127551-af4b90be-703a-4608-b919-b56be3f8325a.png)

### 0-주소 명령어 형식

- `스택(stack) 구조 컴퓨터`에서 사용되는 명령어 형식
- 입력 자료들의 출처와 연산 결과를 기억시킬 **장소가 고정**됨
- 명령어 내에서 **자료의 주소를 지정할 필요가 없는** 명령어 형식
- 주소의 사용 없이 스택에 연산자와 피연산자를 넣었다 꺼내어 연산한 후 결과를 다시 스택에 넣으면서 연산하기 때문에 원래의 자료가 남지 않음
- `TOS`는 Top Of Stack으로, 스택 구조의 최상단을 의미

### 1-주소 명령어 형식

- `단일 누산기 구조의 컴퓨터`에서 사용됨
- 명령어의 수행은 `누산기(AC) 레지스터`에서 이루어짐
- 하나의 주소부를 가지며, 연산에 사용되는 피연산자는 **주소부에 의하여 얻어지는 피연산자**와 **누산기에 기억되어 있는 피연산자**임
- 연산 결과도 누산기에 저장되므로 원래의 자료가 남지 않음

### 2-주소 명령어 형식

- `범용 레지스터 구조의 컴퓨터`에서 사용. 가장 많이 사용됨
- 각 주소부는 `레지스터`나 `주기억 장치`의 주소 지정
- 연산 후 자료 보존 필요 없으면 연산 결과를 **두 자료가 기억된 곳 중 한 레지스터**에 기억시키는 방식

### 3-주소 명령어 형식

- `범용 레지스터 구조의 컴퓨터`에서 사용. 세 개의 주소를 지정
- 각 주소부는 `레지스터`나 `주기억 장치`의 주소 지정
- 프로그램 길이 짧고, 연산 후 **입력 자료가 레지스터에 보존**되는 장점
- 하나의 명령을 수행하기 위해 자주 기억장치에 접근해야 함. 수행 시간이 길어지므로 특수 목적 외에는 사용 X

![image](https://user-images.githubusercontent.com/80818534/145128325-ddc28922-978c-4af0-8d5f-2d629f7fc2e2.png)

## 주소 지정 방식

- 연산에 사용될 데이터를 `주기억 장치`의 어디에서 가져올 것인가를 지정하는 방식
- 명령어의 **명령 코드(op code)**는 수행할 명령 표시
- 명령은 **레지스터나 주기억 장치의 데이터**를 대상으로 수행
- 명령어 수행 중 **피연산자 주소 지정 방법**은 `명령어 주소 지정 방식`에 따라 결정됨

### 묵시적 주소 지정 방식

- 명령어의 정의에 따라 주소가 **암시적으로 정해**지는 방식
- `누산기`를 사용하는 연산에 사용됨
- ex) 누산기에 저장된 값의 보수를 취하라는 명령은 피연산자가 누산기에 있기 때문에 묵시적 주소 지정 방식이 됨
- ex) 스택 구조 컴에서 `0-주소 명령어`는 피연산자가 스택의 맨 위를 지정하기 때문에 묵시적 주소 지정 방식이 됨

![image](https://user-images.githubusercontent.com/80818534/145132239-fdd79589-88be-44a7-bf09-79ece9296080.png)

### 즉시 주소 지정 방식

- 피연산자가 **명령어 자체 내에 포함**된 형태 (실제 데이터)
- 명령 인출과 동시에 기억 장치의 데이터도 **자동 인출**
- 명령어의 실행이 바로 이루어지는 방식

### 직접 주소 지정 방식

- 오퍼랜드 내의 주소를 **실제 데이터 주소**로 직접 표현하는 방식
- **분기 형식**의 명령에서 주로 사용됨

















