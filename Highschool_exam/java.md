# 1학기 자바 시험 준비

문항만 공식 프린트물을 직접적으로 참고했고, 문항 아래 정리한 내용들은 구글링을 통해 조사한 자료들입니다. 시험과는 직접적인 연관이 없을 수 있습니다.

## 1. 자바의 기본 자료형의 표현범위, 접미사 등

| 자료형  | 데이터  | 메모리 크기 | 표현 가능 범위       |
| ------- | ------- | ----------- | -------------------- |
| boolean | 참/거짓 | 1 byte      | true, false          |
| char    | 문자    | 2 byte      | 모든 유니코드 문자   |
| byte    | 정수    | 1 byte      | -128~127             |
| short   | 정수    | 2 byte      | -32768~32767         |
| int     | 정수    | 4 byte      | -21억~21억           |
| long    | 정수    | 8 byte      | 대충 엄청 많아요     |
| float   | 실수    | 4 byte      | 1.4E-45~3.4028235E38 |
| double  | 실수    | 8 byte      | 대충 엄청 많아요     |

- 숫자 상수 끝에 `L`이나 `l` 접미사를 붙이면 long 형으로 바뀐다. (long 접미사)
- 숫자 상수 끝에 `F`나 `f`를 붙이면 float 형으로 바뀐다. (float 접미사)

## 2. 자바의 printf문 출력 지시자

- `System.out.println()` : 줄바꿈 기능 포함. 문자열과 변수명을 함께 사용할 수 있으나 +로 연결해줘야 함.
- `System.out.printf()` : 줄바꿈 기능 미포함. C언어와 사용 형식은 같음.

```java
System.out.println(name + "는 " + age + "살입니다.");
System.out.printf("%s는 %d살입니다.\n", name, age);
```

- printf 사용 시 오른쪽 정렬 가능. ex) %3d
- printf 사용 시 왼쪽 정렬 가능. ex) %-3d
- printf 사용 시 남는 자리에 0 출력 가능. ex) %03d
- printf 사용 시 소수점 아래 자리수 지정 가능. ex) %.2f

| printf 지시자 | 설명                        |
| ------------- | --------------------------- |
| %b            | boolean 형식으로 출력       |
| %d            | 정수 형식으로 출력          |
| %o            | 8진수 형식으로 출력         |
| %x %X         | 16진수 형식으로 출력        |
| %f            | 소수점 형식으로 출력        |
| %c            | 문자 형식으로 출력          |
| %s            | 문자열 형식으로 출력        |
| %e %E         | 지수 표현식의 형식으로 출력 |

## 3. 자바의 콘솔 사용자 입력

- 자바 코드에서 콘솔 입력을 얻기 위해서는 `System.in`을 사용
- 콘솔 입력을 위해서 `InputStream`, `InputStreamReader`, `BufferedReader` 등이 있지만 가장 편리한 `Scanner`를 많이 쓴다.
- `Scanner` 객체에서 콘솔 입력을 받으려면 `next(단어)`, `nextLine(라인)`, `nextInt(정수)` 등을 사용한다.

```java
Scanner sc = new Scanner(System.in);
String word = sc.next();
String line = sc.nextLine();
int number = sc.nextInt();
```

- `next()` : 공백이 나오기 전까지만 입력받음
- `nextLine()` : 엔터를 입력하기 전까지만 입력받음
- `nextInt()` : 정수형을 입력받을 때 사용
- `nextLong()` : long형을 입력받을 때 사용
- `nextDouble()` : double형을 입력받을 때 사용
- `nextFloat()` : float형을 입력받을 때 사용

## 4. 자바의 연산자 (우선순위, 다양한 연산자 종류 및 사용)

| 우선순위 | 연산자                                       | 내용                      |
| -------- | -------------------------------------------- | ------------------------- |
| 1        | (), []                                       | 괄호/대괄호               |
| 2        | !, ~, ++, --                                 | 부정/증감 연산자          |
| 3        | \*, /, %                                     | 곱셈/나눗셈 연산자        |
| 4        | +, -                                         | 덧셈/뺄셈 연산자          |
| 5        | <<, >>, >>>                                  | 비트 단위의 쉬프트 연산자 |
| 6        | <, <=, >, >=                                 | 관계 연산자               |
| 7        | ==, !=                                       | 비교 연산자               |
| 8        | &                                            | 비트 단위의 논리연산자    |
| 9        | ^                                            | 비트 단위의 논리연산자    |
| 10       | \|                                           | 비트 단위의 논리연산자    |
| 11       | &&                                           | 논리곱 연산자             |
| 12       | \|\|                                         | 논리합 연산자             |
| 13       | ?:                                           | 조건 연산자               |
| 14       | =, +=, -=, \*=, /=, %=, <<=, >>=, &=, ^=, ~= | 대입/할당 연산자          |

- 다른 연산자 사용은 아실 것 같으니 비트 연산만 짚고 넘어갑시다
- `|` : OR 연산자. 2진수로 표현된 두 비트 중 하나라도 1일 경우 연산 결과 1
- `&` : AND 연산자. 2진수로 표현된 비트 모두 1일 경우에만 연산 결과가 1
- `^` : XOR 연산자. 2진수로 표현된 두 비트가 다를 경우 1, 같으면 0
- `~` : 비트 전환(반전) 연산자. 0은 1로, 1은 0으로 바꿈. ex) `~10 = -11`
- `<<, >>` : 쉬프트 연산자. 오른쪽 또는 왼쪽으로 각 자리를 이동. (곱셈, 나눗셈 가능)

```java
System.out.println("2 << 3 = " + (2<<3)); // 결과값 16
System.out.println("16 >> 3 = " + (16>>3)); // 결과값 2
```

## 5. 자바의 컴파일 과정

1. 소스파일을 작성한다. (`.java`)
2. 자바 컴파일러를 통해 컴파일한다. 바이트 코드(`.class`)이 생성된다. 바이트 코드의 각 명령어는 1바이트 크기의 Opcode와 추가 피연산자로 이루어져 있다.
3. 컴파일된 바이트 코드를 JVM의 클래스 로더(`Class Loader`)에게 전달한다.
4. 클래스 로더는 `동적 로딩`을 통해 필요한 클래스들을 로딩/링크하여 JVM의 메모리(`런타임 데이터 영역`)에 올린다.
   - 클래스 로더 세부 동작
   1. 로드 : 클래스 파일을 가져와 JVM의 메모리에 로드한다.
   2. 검증 : 자바 언어 명세 및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다.
   3. 준비 : 클래스가 필요로 하는 메모리 할당 (필드, 메서드 인터페이스….)
   4. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
   5. 초기화 : 클래스 변수들은 적절한 값으로 초기화 (static 필드)
5. `실행 엔진`은 JVM 메모리에 올라온 바이트 코드를 명령어 단위로 하나씩 실행
   이 때 `실행 엔진`은 두가지 방식으로 변경 1. `인터프리터` : 바이트 코드 명령어를 하나씩 읽어 해석하고 실행. 하나하나의 실행은 빠르지만, 전체 실행 속도는 느림. 2. `JIT 컴파일러` : 인터프리터의 단점 보완을 위해 도입된 방식. 바이트 코드 전체를 바이너리 코드로 컴파일하고, 바이너리 코드를 직접 실행하는 방식이다. 전체 실행 속도는 인터프리팅보다 빠르다.

![image](https://user-images.githubusercontent.com/80818534/176353854-26b0cff9-f3bf-4695-aceb-b60ff790ce0d.png)

## 6. 클래스와 객체, 메소드, 매개변수, return 타입, 이름 명명 작성 관례 등

## 7. 클래스의 기본 생성자, 생성자 작성 규칙, 객체의 생성 방법 등

## 8. 하나의 클래스에 여러 개의 생성자 생성 방법

## 9. 클래스 변수, 객체 변수, 지역변수, 매개변수, final로 선언된 변수, static으로 선언된 변수 등의 개념

## 10. 자바의 변수명 및 메서드명 생성 규칙

## 11. 정수형 자료형의 오버플로우 시 결과값

## 12. 접근 제한자 (default, private, protected) 등의 접근 가능 범위

## 13. Object 클래스에 대한 이해 (wait, notify, notifyAll, 재정의, 객체화, toString, getClass)

## 14. 추상클래스와 인터페이스의 사용법(선언 방법, 상속 방법 등)

## 15. File 클래스의 메서드 이해 (exist, length, isDirectory, isFile, delete, mkdirs)

## 16. 배열과 리스트 객체의 차이, 데이터 추가, 데이터 가져오기, 리스트 크기 등

## 17. InputStream, OutputStream 메서드 이해

## 18. 스레드 메서드(stop, interrupt, InterruptedException, 쓰레드 우선권, setDaemon(true), join, notify)의 이해

## 19. 다형성, 다중 상속, 추상화의 개념
