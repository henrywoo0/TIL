# 1학기 자바 시험 준비

문항만 공식 프린트물을 직접적으로 참고했고, 문항 아래 정리한 내용들은 구글링을 통해 조사한 자료들입니다. 시험과는 직접적인 연관이 없을 수 있습니다.

## 1. 자바의 기본 자료형의 표현범위, 접미사 등

| 자료형  | 데이터  | 메모리 크기 | 표현 가능 범위       |
| ------- | ------- | ----------- | -------------------- |
| boolean | 참/거짓 | 1 byte      | true, false          |
| char    | 문자    | 2 byte      | 모든 유니코드 문자   |
| byte    | 정수    | 1 byte      | -128~127             |
| short   | 정수    | 2 byte      | -32768~32767         |
| int     | 정수    | 4 byte      | -21억~21억           |
| long    | 정수    | 8 byte      | 대충 엄청 많아요     |
| float   | 실수    | 4 byte      | 1.4E-45~3.4028235E38 |
| double  | 실수    | 8 byte      | 대충 엄청 많아요     |

- 숫자 상수 끝에 `L`이나 `l` 접미사를 붙이면 long 형으로 바뀐다. (long 접미사)
- 숫자 상수 끝에 `F`나 `f`를 붙이면 float 형으로 바뀐다. (float 접미사)

## 2. 자바의 printf문 출력 지시자

- `System.out.println()` : 줄바꿈 기능 포함. 문자열과 변수명을 함께 사용할 수 있으나 +로 연결해줘야 함.
- `System.out.printf()` : 줄바꿈 기능 미포함. C언어와 사용 형식은 같음.

```java
System.out.println(name + "는 " + age + "살입니다.");
System.out.printf("%s는 %d살입니다.\n", name, age);
```

- printf 사용 시 오른쪽 정렬 가능. ex) %3d
- printf 사용 시 왼쪽 정렬 가능. ex) %-3d
- printf 사용 시 남는 자리에 0 출력 가능. ex) %03d
- printf 사용 시 소수점 아래 자리수 지정 가능. ex) %.2f

| printf 지시자 | 설명                        |
| ------------- | --------------------------- |
| %b            | boolean 형식으로 출력       |
| %d            | 정수 형식으로 출력          |
| %o            | 8진수 형식으로 출력         |
| %x %X         | 16진수 형식으로 출력        |
| %f            | 소수점 형식으로 출력        |
| %c            | 문자 형식으로 출력          |
| %s            | 문자열 형식으로 출력        |
| %e %E         | 지수 표현식의 형식으로 출력 |

## 3. 자바의 콘솔 사용자 입력

- 자바 코드에서 콘솔 입력을 얻기 위해서는 `System.in`을 사용
- 콘솔 입력을 위해서 `InputStream`, `InputStreamReader`, `BufferedReader` 등이 있지만 가장 편리한 `Scanner`를 많이 쓴다.
- `Scanner` 객체에서 콘솔 입력을 받으려면 `next(단어)`, `nextLine(라인)`, `nextInt(정수)` 등을 사용한다.

```java
Scanner sc = new Scanner(System.in);
String word = sc.next();
String line = sc.nextLine();
int number = sc.nextInt();
```

- `next()` : 공백이 나오기 전까지만 입력받음
- `nextLine()` : 엔터를 입력하기 전까지만 입력받음
- `nextInt()` : 정수형을 입력받을 때 사용
- `nextLong()` : long형을 입력받을 때 사용
- `nextDouble()` : double형을 입력받을 때 사용
- `nextFloat()` : float형을 입력받을 때 사용

## 4. 자바의 연산자 (우선순위, 다양한 연산자 종류 및 사용)

| 우선순위 | 연산자                                       | 내용                      |
| -------- | -------------------------------------------- | ------------------------- |
| 1        | (), []                                       | 괄호/대괄호               |
| 2        | !, ~, ++, --                                 | 부정/증감 연산자          |
| 3        | \*, /, %                                     | 곱셈/나눗셈 연산자        |
| 4        | +, -                                         | 덧셈/뺄셈 연산자          |
| 5        | <<, >>, >>>                                  | 비트 단위의 쉬프트 연산자 |
| 6        | <, <=, >, >=                                 | 관계 연산자               |
| 7        | ==, !=                                       | 비교 연산자               |
| 8        | &                                            | 비트 단위의 논리연산자    |
| 9        | ^                                            | 비트 단위의 논리연산자    |
| 10       | \|                                           | 비트 단위의 논리연산자    |
| 11       | &&                                           | 논리곱 연산자             |
| 12       | \|\|                                         | 논리합 연산자             |
| 13       | ?:                                           | 조건 연산자               |
| 14       | =, +=, -=, \*=, /=, %=, <<=, >>=, &=, ^=, ~= | 대입/할당 연산자          |

- 다른 연산자 사용은 아실 것 같으니 비트 연산만 짚고 넘어갑시다
- `|` : OR 연산자. 2진수로 표현된 두 비트 중 하나라도 1일 경우 연산 결과 1
- `&` : AND 연산자. 2진수로 표현된 비트 모두 1일 경우에만 연산 결과가 1
- `^` : XOR 연산자. 2진수로 표현된 두 비트가 다를 경우 1, 같으면 0
- `~` : 비트 전환(반전) 연산자. 0은 1로, 1은 0으로 바꿈. ex) `~10 = -11`
- `<<, >>` : 쉬프트 연산자. 오른쪽 또는 왼쪽으로 각 자리를 이동. (곱셈, 나눗셈 가능)

```java
System.out.println("2 << 3 = " + (2<<3)); // 결과값 16
System.out.println("16 >> 3 = " + (16>>3)); // 결과값 2
```

## 5. 자바의 컴파일 과정

1. 소스파일을 작성한다. (`.java`)
2. 자바 컴파일러를 통해 컴파일한다. 바이트 코드(`.class`)이 생성된다. 바이트 코드의 각 명령어는 1바이트 크기의 Opcode와 추가 피연산자로 이루어져 있다.
3. 컴파일된 바이트 코드를 JVM의 클래스 로더(`Class Loader`)에게 전달한다.
4. 클래스 로더는 `동적 로딩`을 통해 필요한 클래스들을 로딩/링크하여 JVM의 메모리(`런타임 데이터 영역`)에 올린다.
   - 클래스 로더 세부 동작
   1. 로드 : 클래스 파일을 가져와 JVM의 메모리에 로드한다.
   2. 검증 : 자바 언어 명세 및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다.
   3. 준비 : 클래스가 필요로 하는 메모리 할당 (필드, 메서드 인터페이스….)
   4. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
   5. 초기화 : 클래스 변수들은 적절한 값으로 초기화 (static 필드)
5. `실행 엔진`은 JVM 메모리에 올라온 바이트 코드를 명령어 단위로 하나씩 실행
   이 때 `실행 엔진`은 두가지 방식으로 변경 1. `인터프리터` : 바이트 코드 명령어를 하나씩 읽어 해석하고 실행. 하나하나의 실행은 빠르지만, 전체 실행 속도는 느림. 2. `JIT 컴파일러` : 인터프리터의 단점 보완을 위해 도입된 방식. 바이트 코드 전체를 바이너리 코드로 컴파일하고, 바이너리 코드를 직접 실행하는 방식이다. 전체 실행 속도는 인터프리팅보다 빠르다.

![image](https://user-images.githubusercontent.com/80818534/176353854-26b0cff9-f3bf-4695-aceb-b60ff790ce0d.png)

## 6. 클래스와 객체, 메소드, 매개변수, return 타입, 이름 명명 작성 관례 등

- 이름 명명 작성 관례 : 클래스명은 대문자로 시작하는 Camel Case, 메서드명 및 변수명은 소문자로 시작하는 Camel Case, 그 외 상수는 모두 대문자, 패키지명은 모두 소문자

## 7. 클래스의 기본 생성자, 생성자 작성 규칙, 객체의 생성 방법 등

- `기본 생성자` : 매개변수를 하나도 가지지 않으며, 아무런 명령을 포함하지 않음. 개발자가 생성자를 정의하지 않았을 때 자동으로 생김. (`클래스이름() {}`)
- `생성자 작성 규칙` : 클래스명과 메서드명을 동일하게 작성하고, 리턴 타입을 정의하지 않는다.
- `객체의 생성 방법` : `new` 키워드와 생성자를 활용해 인스턴스를 생성

```java
Student student = new Student("우준성");
```

## 8. 하나의 클래스에 여러 개의 생성자 생성 방법

- `생성자 오버로딩` : 생성자의 매개변수 타입과 개수가 다르게 하여, 여러 생성자를 가질 수 있다.

```java
public class Car{
    String name;
    int number;

    public Car(){

    }

    public Car(String name){
        this.name = name;
    }

    public Car(String name, int number){
        this.name = name;
        this.number = number;
    }
}
```

## 9. 클래스 변수, 객체 변수, 지역변수, 매개변수, final로 선언된 변수, static으로 선언된 변수 등의 개념

- `클래스 변수` : 클래스 내에 작성한 멤버 변수에 static을 붙임. 클래스의 모든 인스턴스가 공통된 값을 공유
- `멤버 변수` : 일반적으로 클래스에서 사용하는 변수
- `지역 변수` : 메서드 안에서 사용하는 변수
- `매개변수` : 메서드에 인자로 받는 변수
- `final 변수` : 상수. 변경할 수 없음

## 10. 자바의 변수명 및 메서드명 생성 규칙

- 변수명은 소문자로 시작하는 Camel Case
- 메서드명은 소문자로 시작하는 Camel Case, 동사로 시작 (ex. getName())

## 11. 정수형 자료형의 오버플로우 시 결과값

- int형에서 `2147483647 + 1`을 할 경우 `-2147483648`이 됨 (오버플로우)
- 보통 오버플로우 시 그 자료형이 표현할 수 있는 최소값이 됨

## 12. 접근 제한자 (default, private, protected) 등의 접근 가능 범위

- `default` : 같은 패키지 내에서만 접근 가능
- `private` : 같은 클래스에서만 접근 가능
- `protected` : 같은 패키지이거나 상속한 클래스에서 접근 가능
- `public`: 어디서든 접근 가능

## 13. Object 클래스에 대한 이해 (wait, notify, notifyAll, 재정의, 객체화, toString, getClass)

- `wait()` : 해당 객체의 다른 스레드를 일시적으로 대기시킴.
- `notify()` : 해당 객체의 대기하는 스레드 하나를 다시 실행
- `notifyAll()` : 해당 객체의 대기하는 모든 스레드를 다시 실행
- `toString()` : 해당 객체의 정보를 문자열로 반환 (재정의하지 않으면 클래스.이름@hashCode 문자열 반환)
- `getClass()` : 해당 객체의 클래스 타입 반환
- 객체화 하려면 `new Object()`
- 해당 메서드들을 Overriding해서 구현 내용을 바꿀 수 있음 (toString, equals, hashCode 등의 메서드들은 보통 오버라이딩해서 사용)

## 14. 추상클래스와 인터페이스의 사용법(선언 방법, 상속 방법 등)

- 추상클래스는 `extends`를 이용하여, 인터페이스는 `implements`를 이용하여 상속(구현)한다.
- 추상클래스는 class 앞에 `abstract` 키워드를 붙여야 한다. (메서드에도 `abstract` 붙여야 함)
- 추상클래스의 상수에는 `static`을 명시해줘야 한다.
- 인터페이스의 모든 필드는 `public static final`이어야 한다. (생략 가능)
- 인터페이스의 모든 메서드는 `public abstract`이어야 한다. (생략 가능)
- 일반 상속은 다중 상속이 안 되는 반면, 인터페이스를 사용하면 `다중 상속`이 가능하다.

## 15. File 클래스의 메서드 이해 (exist, length, isDirectory, isFile, delete, mkdirs)

- `File 클래스` : 파일, 폴더에 대한 제어를 하는데 사용하는 클래스
- `boolean exists()` : 파일의 실존 여부 리턴
- `long length()` : 해당 경로 파일의 길이(크기) 반환
- `boolean isDirectory()` : 해당 경로가 디렉토리(폴더)인지 여부 반환 (파일이라면 false)
- `boolean isFile()` : 해당 경로가 일반 파일인지 여부 반환 (디렉토리면 false)
- `boolean delete()` : 파일이나 폴더 삭제 (폴더가 비어있지 않으면 false)
- `boolean mkdirs()` : 존재하지 않는 부모 폴더까지 포함해서 해당 경로에 폴더(디렉토리) 생성

## 16. 배열과 리스트 객체의 차이, 데이터 추가, 데이터 가져오기, 리스트 크기 등

- 배열 : 고정적인 크기, 연속적인 메모리 공간, 원소 삽입/제거 시 다른 원소들을 수동으로 옮겨줘야 함
- 리스트(컬렉션 프레임워크) : 가변적인 크기, 메서드를 활용하기 때문에 원소 삽입/삭제 시에도 중간에 빈 공간이 생기지 않음
- `List` 인터페이스를 구현한 클래스에는 `LinkedList`, `ArrayList` 등이 있음
- `add(인덱스, 값)` : 리스트에 원소 추가. 인덱스는 생략 가능하며, 생략 시 맨 뒤에 원소 추가.
- `get(인덱스)` : 해당 인덱스의 값 반환
- `set(인덱스, 값)` : 해당 인덱스 값 변경
- `size()` : 리스트 요소 개수 반환

## 17. InputStream, OutputStream 메서드 이해

- `InputStream` : 바이트 기반 입력 스트림의 최상위 클래스 (추상 클래스)
- `OutputStream` : 바이트 기반 출력 스트림의 최상위 클래스 (추상 클래스)

![image](https://user-images.githubusercontent.com/80818534/176428916-51154d40-0d56-44e0-8088-cd118e713945.png)

- `InputStream`의 메서드들
- `void close()` : 현재 열려있는 InputStream을 닫음
- `abstract int read()` : InputStream에서 한 바이트를 읽어서 int값으로 반환
- `int read(byte[] b)` : byte[]만큼 데이터를 읽어서 b에 저장하고 읽은 바이트 수를 반환
- `int read(byte[] b, int off, int len)` : len만큼 읽어서 byte[] b의 off위치에 저장하고 읽은 바이트 수를 반환

<hr>

- `void close()` : OutputStream을 닫음
- `void flush()` : 버퍼에 남아있는 출력 스트림을 출력
- `void write(byte[] b)` : 버퍼의 내용을 출력
- `void write(byte[] b, int off, int len)` : b 배열 안에 있는 시작 off부터 len만큼 출력

## 18. 스레드 메서드(stop, interrupt, InterruptedException, 쓰레드 우선권, setDaemon(true), join, notify)의 이해

- `join()` : 다른 스레드 작업이 모두 끝날 때까지 기다리기 (인자로 시간 전달 가능)
- `stop()` : 스레드 종료 (안전하지 못함)
- `notify()` : wait 상태의 스레드를 깨워서 실행한다
- `interrupt()` : `InterruptException` 발생, 스레드 종료
- 쓰레드 우선권 : `setPriority()`에 인자로 1~10 전달. 숫자가 높을수록 우선순위가 높음
- `setDaemon(true)` : 해당 스레드를 데몬 스레드를 만드는 메서드 (`start()` 전에 호출해야 함)
- 데몬 스레드 : 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드

## 19. 다형성, 다중 상속, 추상화의 개념

- `다형성(polymorphism)` : 하나의 객체가 여러 가지 타입을 가질 수 있는 것
- 자바에서는 이러한 다형성을 부모-자식 간의 상속으로 구현한다.

```java
class Parent { ... }
class Child extends Parent { ... }

...

Parent pa = new Parent(); // 허용
Child ch = new Child();   // 허용
Parent pc = new Child();  // 허용
Child cp = new Parent();  // 오류 발생.
```

- 다중 상속 : 인터페이스 implements를 통해 가능하다.
- `추상화` : 공통된 특징을 묶어 하나의 클래스로 정의하는 것
